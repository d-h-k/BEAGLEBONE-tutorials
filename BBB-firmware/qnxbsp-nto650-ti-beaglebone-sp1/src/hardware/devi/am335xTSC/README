This directory contains sample code showing how to 
write device and protocol modules.  The module
samp_dev is an example of a device module.  The
samp_proto module is the microsoft mouse protocol
module, heavily commented.  Use these files as a guide
in creating input drivers.

The following is some additional info you will find 
useful.

Data Format
-----------

Device modules can pass up data in any format they want up
to protocol modules.  But protocol modules must pass up
data in a specific format to filter modules.  

Keyboard class protocol modules must format the data they
receive from the device into a struct packet_kbd before
sending up.  

Relative class protocol modules must format data into
a struct packet_rel.

Absolute class protocol modules must format data into
a struct packet_abs.

See the header devi.h for the format of these structures.
All these structures have a timestamp field, fill them in
using the library call clk_get().  


Keyboard devices
----------------

When writing keyboard device modules, the protocol/filter layers will
expect make and break scan codes indicating when a key is pressed
down and released.  The easiest thing to do is to map the scan codes
your device sends to the standard PC scan codes.  This way you won't
have to make any filter layer changes, it will all just work like a
normal PC keyboard.  Standard PC scan codes are available in any
PC hardware book.  If you need them contact someone at qssl.

When passing up a struct packet_kbd to the filter layer, all you
need to do is fill in the key_scan field of the struct _keyboard_data
with the scan code and the flags field with KEY_SCAN_VALID.

The keyboard filter layer will read in a keyboard definition file
and interpret the scan codes it receives based on the contents of
this file.  See the photon docs for an explanation of the format
of this file.  The keyboard definition files are typically kept in
the location: $PHOTON_PATH/keyboard, where $PHOTON_PATH depends on
you system configuration.  In this directory there is a file called
sample.kdef which provides a sample definition file.  .kdef files
are compiled into .kbd files using the utilities kbcvt and mkkbd. 
These utilities come standard with qnx4 photon, and will work on
nto as well.  If you need the actual executables to work on nto,
contact qssl.

Again you shouldn't have to play around with these mapping files
very much if you map your scan codes appropriately.  The only
place where you might need to modify these files is if your keyboard
has special keys.  In this case you would start with a standard definition
file, say the US keyboard one, en_US_101.kdef, and add your unique 
scan codes in.

When the driver starts up and initilizes the keyboard filter module,
the filter module will attempt to load in a mapping definition file.
The locations it looks for the file are defined in order by:

1) command line parameter to the keyboard filter, -k <file>
2) env variable KBD
3) $PHOTON_PATH/keyboard
4) /pkg/qssl/photon/keyboard/

If a file isn't found, the keyboard filter will use a built in
table emulating a standard US keyboard layout.


Absolute devices
----------------

The elo directory contains an example of a touchscreen protocol
module.

Absolute devices like touchscreens need to be calibrated.  They will
typically generate "raw" coordinates which must be translated into
actual screen coordinates.  The screen coordinates they are translated
into depends on the screen resolution.  

The device/protocol layer module will receive raw coordinates from 
the touchscreen device, format a packet_abs structure and pass it
up to the absolute filter.

The absolute filter module takes care of translating raw coordinates
to screen coordinates.  To do this it will attempt to read in a calibration
file on startup, the default name and location of this file is:

1) command line option to absoulte filter, -f <filename>
2) ABSF env variable
3) /etc/config/trap/acalib/acalib.<hostname>

The format of this file is:

XLxYL:XHxYH:XRL XRH YRL YRH SWAP

where:

XL: X screen coordinate of upper left hand side, typically 0
YL: Y screen coordinate of upper left hand side, typically 0
XH: X screen coordinate of lower right side, typically X screen resolution - 1
YH: Y screen coordinate of lower right side, typically Y screen resolution - 1

XRL : Raw touchscreen X coord at upper left hand side
XRH : Raw touchscreen X coord at lower right hand side
YRL : Raw touchscreen Y coord at upper left hand side
YRH : Raw touchscreen Y coord at lower right hand size

SWAP : whether to swap X or Y axes, 0 no, 1 yes.  Safe to leave this as 0.


This file is typically generated by the touchscreen calibration photon
application, calib.  It will start up, send a message to the devi driver
asking it to switch to raw mode, then solicit coordinate info by asking
the user to touch the screen at all four corners and the middle.  After
doing this, calib will format up the absf file, send a calibration message
to the devi driver and write the file.



Writing a combo Device/Protocol module
--------------------------------------

If you are writing a driver for a custom type of device in which it
doesn't make sense to split up the funtionality of device and protocol
you can write a combo module.  Simple proceed as usual, fill in your
callbacks, talk to your device, interpret its protocol, etc.  In addition
there are two things you have to do:

1) In the type field put in DEVI_MODULE_TYPE_DEVICE | DEVI_MODULE_TYPE_PROTO
   in addition to the DEVI_CLASS_ manifest.

2) When you've interpreted the data from your device, package up a 
   struct packet_* (depending on your class of device) and send it
   up.


A Note about re-entrancy
-------------------------

Because the devi framework is multithreaded, you should be aware
of a possible re-entrancy issue.  When a devi driver is invoked,
a module may be specified multiple times, where each invocation will
belong to a separate event bus line.  An example is the keyboard
controller device module, kb.  This module can be used to communicate
with a keyboard and a ps/2 mouse.  We would invoke devi as follows:

devi-hirun kbd kb ps2 kb -2

Here we will have two event bus lines, one for the keyboard and
one for the mouse.  Upon initialization, the input framework will
use the static kb input_module_t data structure for the one of
the bus lines and dynamically allocate/copy another one for the
other bus line.  If you keep your module specific data confined
to the private data member of the module structure you won't have
any problems with re-entrancy.  But if your module contains global
variables then you'll have to use some sort of mutual exclusion
mechanism for protection.  Note you don't have to ensure that the
init(), reset(), and parm() callbacks are re-entrant because they
are always called from a single thread upon initialization (however if
for some reason you need to call them when the runtime system is up,
then you have to worry about this).  The callbacks used at runtime
are the ones at risk, ie the pulse() callback.

See the keyboard controller module code for more info, hirun/kb.c


Testing/Debugging your driver
-----------------------------

You can use the standard debugger to debug your driver code or
you can use the old printf() method.  To use printf() make sure
you specify at least 1 -v command line option to your driver as
the devi lib will close stdout otherwise.  

You can run your driver without graphics being started simply
by starting the Photon server first.

If you are writing a touchscreen driver and are just testing out
getting raw coordinates, then you can use the -G option to devi to 
tell it not to search for a graphics region when it starts up.  

